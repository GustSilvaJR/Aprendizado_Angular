 ---------------------------------
|INFORMAÇÕES A RESPEITO DO ANGULAR|
 ---------------------------------

Instalando CLI do Angular -> npm install -g @angular/cli
________________________________________________________________

Criar novo projeto -> ng new <nome_projeto>
________________________________________________________________

Rodando o projeto -> ng serve
________________________________________________________________

ng g m <name_archieve> -> Cria um novo módulo no projeto Angular.
________________________________________________________________

Criar um componente pelo CLI -> ng generate component <nome_pasta></nome_componente>


________________________________________________________________
INFORMAÇÕES GERAIS SOBRE ESTRUTURAS USADAS NO ANGULAR


    ngModule -> O ngModule fica no dentro do app.module sempre que crio o projeto, e nele consigo passar algumas informações importantes em determinados
    escopos. Sendo eles:
                    -> Declarations: Onde eu declaro os componentes criados na minha aplicação;

                    -> Imports: A partir daqui consigo importar modulos de fora da minha aplicação para que eu possa utilizar suas funcionalidades.
                    Um bom exemplo é p Forms-Module, permitindo, ao ser importado, que eu utilize o ng-model;

                    ->Providers: Neste campo consigo declarar os serviços que irei utilizar, nestes serviço defino as apis que irei consumir no backend.

                    ->Bootstrap: Não é para estilo, apesar do nome. Ele é utilizado para definir qual arquivo do nosso sistema será nosso componente inicial.

                    ->Export: É possível exportar um modulo criado para ser utilizado em outras partes da minha aplicação, deixando ele de certa forma mais seletivel.


    ngOnInit() -> É utilizado dentro dos arquivos .ts de um componente, atuando como um método da classe que
geralmente se é criada para definir as logicas do componente. Para usar é necessário dar um
"  implements On init " na classe.
    Sua função é definir dentro de seu escopo o que o componente fará assim que for inicializado,
desde a consumir uma api ou alterar algum visual estático da tela com base em alguma lógica definida
pelo programador. Exemplo:

    export class <nome_qualquer> implements OnInit{
        
        ...
        
        ngOnInit():void {
            ...
        }

    }

-------------------------------------------------------------------------------

    ngOnChange() -> Este ciclo de vida do Angular é utilizado para que sempre quando um componente
receber algum valor a pratir do decorator "  @Input  ", ele seja acionado, executando alguma
instrução.

    O @input pode ser utilizado por exemplo em algum atributo de um componente, como por exemplo:

    export class Title implements onChange {

        @Input() public nome: string = "Gustavo";

        /*Dessa maneira o atributo irá esperar algum valor dentro de uma tag nome assim 
        quando se for instanciar o component. E caso não for passado, ele irá utilizar
        o valor default que foi passado inicialmente na classe: "Gustavo"

        Exemplo:
            <app-title nome="Júlio"></app-tile>  
        */

        ngOnChanges(changes: SimpleChanges): void {
            console.log("Alterado!");
            console.log(changes);
        }
    }

    Dessa forma, assim que algum parametro for passado na instancia do componente, a função
OnChange definida dentro da classe será executada

-------------------------------------------------------------------------------

ngDoCheck() -> É acionado logo depois do ngOnInit e além disso irá ser acionado 
               novamente sempre que houver algum tipo de alteração, qualquer que seja.


ngAfterContentInit() -> Este evento é acionado antes do ngAfterViewInit, para carregar todos os conteudos externos que 
                        serao carregados na minha view.


ngAfterContentChecked() -> Evento acionado após checar todos componentes externos que foram carregados para a view                      


ngAfterViewInit() -> Esse caso se diferencia do ngOnInit devido ao fato de só ser acionado quando todos os elementos do 
                    componente forem inicializados, incluíndo views filhas que sejam renderizadas dentro dele. (Componente dentro de um componente);
                    Já no caso do ngOnInit, ele é acionado logo na inicializacao de uma view, e antes de que qualquer um 
                    dos componentes filhos dessa view sejam renderizados.

ngAfterViewChecked() -> Será acionado assim que a view principal toda for checada junto de todas suas views filhas.

ngOnDestroy() -> Irei utilizar para criar um evento a ser acionado assim que um componente for destruído. Esse evento, eu coloco
                no próprio componente, assim, quando devido a alguma lógica seja de nível superior como por exemplo uma variavel criada
                dentro de app.component.ts que controla o estado true ou false (repsesentando visivel ou nao) para o componente
                e é atribuida a um ngFor na hora de se criar a tag do component em app.component.html, e a partir de algum 
                botao que ao receber um clique do usuario acione uma funcao dentro de ap.c....ts que sete essa variavel para
                false, fazendo o component nao ser mais exibido. O retirando completamente do corpo da pagina html e estourando
                seu evento onDestroy

_________________________________________________________________________________________________________________________________________________________
CONCEITOS

    Interpolação-> É o fato de renderizar de forma dinâmica um dado na tela. A partir dessa ferramente consigo passar, por exemplo, um atributo da minha classe
    .ts do componene para a parte html do componente, basta utilizar os colchetes { <att_name> }

    Property Binding-> Basicamente consigo linkar um atributo da minha classe em algum parametro que estiver passando pro meu elemento html, como por exemplo:

            <button [disabled]="disabledState" > Salvar </button>  //Dessa forma o att disabled do elemento button estará associado a um atributo disabledState
                                                                    de dentro da classe .ts, que setaria como um boolean, e de acordo com a lógica da aplicaçao
                                                                    conseguiria controlar o estado desse botão.

    Event Binding -> Basicamente é a utilização dos eventos onclick, onchange, etc... do javascript, os associando a alguma função que criei no meu arquivo .ts

    Two-way Binding -> É uma forma de apresentar os dados de um atributo no documento html e também conseguir o alterar na classe a partir de alguma ação feita no html
    Exemplo:

            <input type="text" [(ngModel)] = "nome"/> //Dessa forma associei o value do meu input com o atributo nome do da minha classe criada dentro do arquivo .ts
                                                        Dessa forma, assim que eu alterar o valor dentro do input, também estarei alterando o valor do atributo no 
                                                        arquivo .ts 

_________________________________________________________________________________________________________________________________________________________
DIRETIVAS   

        
        Diretivas estruturais -> São diretivas centradas em alterar elementos da árvore DOM, seja inserindo, alterando ou removendo.

        Diretivas de atributos -> Estas já estão direcionadas a alterações que envolvam a aparência da aplicação, como alteração de classes, estilos inline e ademais


-----------------------------------------------------------
DIRETIVAS ESTRUTURAIS

    *ngIf -> Consigo verificar uma condição antes de implementar um elemento no DOM ou até mesmo um componente, daí caso a condição for true eu renderizo ele, e caso false não

        Exemplo:

            <span *ngIf="resultBrasilGameSaturday==true; else lose">Venceu</span>
    
            <ng-template #lose>
                <span *ngIf="resultBrasilGameSaturday==false; else teste">Perdeu</span>
            </ng-template>

            <ng-template #teste>
                <span>Jogo Ainda Nao Ocorreu</span>
            </ng-template>
________________________________________________________
    *ngFor -> Iterar sobre um array ou objeto 
        Exemplo: 
            
        <tr *ngFor="let user of users; let i = index;">
            <td>{{i}}</td>
            <td>{{user.name}}</td>
            <td>{{user.idade}}</td>
        </tr>

________________________________________________________
    *ngSwitch -> Realizar um switgh case
        Exemplo:

        <div [ngSwitch]="auxSwitch">
            <span *ngSwitchCase="'Gustavo'">
                Usuario logado: Gustavo
            </span>
            <span *ngSwitchCase="'Sabrina'">
                Usuario logado: Sabrina
            </span>
            <span *ngSwitchDefault>
                Usuario logado: Desconhecido
            </span>
        </div>

-----------------------------------------------------------
DIRETIVAS DE ATRIBUTO

    ngClass -> Consigo definir a classe de um elemento html de acordo com alguma lógica. Assim
               a alterando de forma dinâmica.

               Exemplo:
                    <h2 [ngClass]="{'active':valor, 'disabled': !valor}" >
                        Alterando Classe de Acordo com Diretivas de Atributos
                    </h2>
                Neste caso o valor é um atributo da minha classe, e é inicializado como false.

                Daí dentro da funcao onInit, implementei um metodo setInterval que de 500 mili em 500 mili
                altera o valor do atributo para o inverso, false, true, false, true ...

                E as classes defini dentro do arquivo css correspondente ao componente

________________________________________________________________________________________________________________
    ngStyle -> Basicamente igual ao de cima, só que a partir deste eu também consigo incluir estilos
               brutos, semelhantes ao estilo inline comum do css. 
               Aqui eu tamém consigo implementar os mesmo estilos citados e exemplificados acima

               Exepmplo: 

                     <h2 [ngStyle]="{background:'red'}">
                        Alterando a partir do ngStyle
                     </h2>


________________________________________________________________________________________________________________
    ngModel -> Consigo implementar um two way data biding em algum atributo da minha classe e com base
               nisso realizar algum tipo de valdiação. 

               Exemplo:
                    <input type="text" [(ngModel)]="nameNewUser" />
                Em que o nameNewUser é um atributo da minha classe

________________________________________________________________________________________________________________
    ngTemplate -> Utilizado para realizar uma validação antes de renderizar um elemento html do DOM.
                  Dessa forma, o elemento html colocado dentro do template sequer é criado caso nao passe na validação

    Exemplo:
        <ng-template [ngIf]="show">
            <h3>Mandou me exibir ?!</h3>
        </ng-template>

        <button (click)="showTemp()">{{btnTemp}}</button>

    Nesse caso o template só será renderizado caso a variavel show for true.

________________________________________________________________________________________________________________
    ngContent -> A partir dessa diretiva consigo reutilizar um componente passando algumas pequenas alteraçoes.
                 As alterações são passadas dentro do componente main, basta colocar os elementos html
                 que deseja incluir, dentro do escopo da tag do componente.

    Exemplo:

        <ng-content select="p"></ng-content //Dentro do componente 

        <app-diretivas-atributos>
            <p>Passando parâmetro através do escopo da tag do componente dentro do componente main</p>
        </app-diretivas-atributos> //NO COMPONENTE MAIN

________________________________________________________________________________________________________________
    Pipe -> Serve para passarmos algum comando para tratar algum dado estamos interpolando.
            O Angular conta com um leque enorme de ferramentas para  realizar diversas formatações 
            nos dados.

            Exemplo:

                {{date | date: 'dd/MM/yyyy}}


_________________________________________________________________________________________________________________________________________________________
CONFIGURANDO UM NOVO MÓDULO NA APLICAÇÃO


        Após executar o comando ng g m <name_module>, terei meu novo modulo criado dentro da minha pasta App. Em que uma pasta nova será criada com o nome que passamos.
    Também será criado um novo arquivo <name>.module.ts para nosso novo módulo.

        Em seguida posso rodar o comando ng g c <name_component> <way_to_my_new_component>  
    Dessa forma irei criar um novo componente dentro do meu novo componente criado.

        Agora para conseguir utilizar esse módulo em outras partes do meu sistema eu preciso exportar esse módulo. Para tal, basta ir no arquivo module do novo componente 
    criado, e dentro de NgModule, no atributo exports, declarar o nome do meu componente que desejo exportar. (O nome adicionado é o nome da classe referente ao nosso componente
    dentro do arquivo .ts dele). Assim, em seguida devo importar a classe exportada no nosso novo arquivo <name>.module.ts do modulo que criamos para
    dentro do outro módulo em que eu for utilizar esse componente. Dentro de NgModules, no atributo Imports, basta adicionar o nome exportado.

        Depois destes passos, podemos utilziar normalmente o novo componente criado dentro do nosso mais recente módulo no outro módulo para o qual o importamos.   


_________________________________________________________________________________________________________________________________________________________
COMUNICAÇÃO ENTRE COMPONENTES

    @Input() -> Consigo utilizar uma entrada de dados de um componente para outro. Basta eu definir
    no componente que irá receber algum dado a tag @Input logo no inicio da criação do atributo.

        Exemplo:

            @Input() public nomeUsuarioLogado:string;  

            Em seguida, basta no momento em que eu for declarar o componente eu criar um atributo;
            com o nome correspondente ao que declarei no input.

            <app-input nomeUsuarioLogado="Gustavo"></app-input>
________________________________________________________
    
    @Output() -> A partir desse decorator é possível se enviar um dado para fora de um componente, basta
    criar um novo atributo nesse componente e atribuir a ele um event emitter. 
        Em seguida, para enviar uma determinado atributo, se tem que acessar o emit dentro desse novo 
    atributo criado e passar como parametro o valor.

        Para captar o valor que foi enviado, no componente pai onde se instanciou a tag do componente que 
    está enviando o dado deve-se colocar um atributo, este atributo é o que criamos e atribuimos o event emitter.
        Ele irá receber uma função que deverá ser criada no componente pai, e será responsavel por receber os dados
    que serão enviados assim que o evento for acionado no eventEmitter.

    Exemplo:

        @Output() public sendData = new EventEmitter(); //Criando event emitter

        this.sendData.emit(this.comidas[index]); //Emitindo um dado a partir do emit de dentro do eventEmitter 

        <app-output (sendData)="setData($event)"></app-output> //Atribuindo meu atributo eventEmitter como atributo da
                                                               //Tag do componente filho e linkando a ele a função que irá receber o dado
                                                               // e que foi criada no componente pai

        public setData(event:food){ //Função para captar o valor informado
            this.dataFood=event;
        }



_________________________________________________________________________________________________________________________________________________________
PROGRAMAÇÃO REATIVA

        É um paradigma baseado em eventos, dessa forma se tendo um software mais reativo do que proativo. Um software proativo a todo momento busca estar 
    executando algum algoritmo, acabando por consumir muitos dados do processador.
        Já na programação reativa temos um software que atua de uma maneira mais reativa. Em que executará determinado bloco de código de acordo com algum
    evento que for acionado.

        Basicamente funciona com um SUBJECT que fica responsável por vigiar a ocorrência de um determinado evento, e direcionar para os interessados.
        
        Os Observers seriam nossas abstrações que estariam interessadas em determinados eventos e irão receber a notificação que esse evento foi acionado
    a partir do SUBJECT, e asism irão executar determinadas ações.

        Os observers precisam se registrar em qual evento estão interessados e fazem isso a partir do SUBJECT.

        Além disso se tem propriamente os eventos. Eles nao ficam armazenados dentro do Subject, mas o subject consegue captar quando o evento cadastrado nele
    ocorrer.

    Observables: Este padrão é a base fundamental da programação reativa e funciona como uma promisse, porém com algumas funcionalidades a mais.
                
                A partir deste modelo é possível receber um fluxo de dados, e não só um valor em específico como é na promisse. Além de ser possível
                cancelar o obserable no meio.

                Além disso, a parti dele se pode fazer tanto requisições assíncronas como síncronas. 

________________________________________________________
SUBSCRIBE
    
        Dentro do meu serviço eu consigo criar um EventEmitter que irei utilizar para emitir um determinado evento que eu queira. Há diversas funcionalidades no
    tipo EventEmitter, como por exemplo varEventEmiiter.emit(value), que gera um evento para retornar um determinado valor.

        Daí, para que um componente consiga utilizar esse evento é necessário que ele se inscreva, e para isso se utiliza o subscribe.
    Se inscrever nada mais é que fazer com que o componente fique "observando" até que o evento seja disparado, para assim receber o valor.

    Exemplo:
        (NoServiço)
            //Criando
            public eventEmitter = new EventEmitter();

            //Emitindo um evento
            this.eventEmitter.emit("Fui acionado");

        (NoComponente)
            //Injeção de dependência
            constructor(private myService: MyService)

            //Inscrição no evento
            this.myService.eventEmitter.subscribe({
                next: (res) => {
                    ...do something
                },
                error: (err) => {
                    ...do something
                }    
            });    


_________________________________________________________________________________________________________________________________________________________
SERVIÇOS

    São utilizados principalmente para recuperar dados de APIs e a partir deles os apresentar em um componente por exemplo.

    Em um serviço posso destinar diversas funções que irão trabalhar em um determinado contexto ou funcionalidade em específico.

    Comando para a criação:

        ng g s <caminho+nome>

    Como uilizar em um componente:
        
        Para usá-lo, é necessário que se faça  ainjeção de dependência no componente a partir do arquivo .ts, dessa forma conseguindo acessar o serviço:

            constructor(private foodListService: FoodListService) { } //Exemplo de injeção de dependência de um serviço chamado FoodListService

_________________________________________________________________________________________________________________________________________________________
FORMULÁRIOS

    <input type="text" #meuInput /> //A partir desta diretiva implementada (#meuInput) eu consigo recuperar o valor digitado dentro do input e envialo para o back end por exemplo
    
    <button (click)="enviaInput(meuInput)">Envar</button> //Exeplo de recuperação do valor do input

_________________________________________________________________________________________________________________________________________________________
HttpClient

        Este é um módulo que me permite realizar requisições http. A partir dele se faz requisições reativas, utilizando Observables para se criar um evento,
    como se fosse pelo eventEmitter, fazendo assim com que os componentes que forem utilizar essa requisição tenham que se inscrever.

        Para conseguir utilizar, antes preciso importar o HttpClient dentro do modulo.ts da aplicação e em seguida dentro do meu serviço.
    
    Exemplo:

        (dentro de Module)
            import { HttpClientModule } from '@angular/common/http';
            imports: [
                CommonModule,
                HttpClientModule
            ]

        (dentro do Serviço)
            import { HttpClient } from '@angular/common/http';
            import { Observable } from 'rxjs';

            public foodList(): Observable<Food>{
                return this.httpClient.get<Food>(this.url+'foods') //Realizando uma requisição get
                .pipe(
                  res => res,
                  error => error,
                )
            }

_________________________________________________________________________________________________________________________________________________________
FORMULÁRIOS COM NGFORM

    Inicialmente preciso importar o ngform no meu arquivo .module.ts e em seguida ja posso iniciar a criação dos meus formulários.

    //No # específico o nome que irá identificar meu formulário e atribuo a ele o ngForm, definindo que as estruturas utilziadas serão baseadas nesse módulo
    <form #myForm=ngForm></form> 

________________________________________________________ 
INPUTS PADRAO:

        <input type="text" name="<name_input>" ngModel /> //Dessa forma faço um binding do name que passei pro meu input com um elemento que acessarei
                                                          // dentro do #myForm
 ________________________________________________________
RADIO BUTTONS
        //Basicamente segue o mesmo padrao do input text
        <div>
            <input type="radio" name="tecnologia" value="HTML" ngModel/>
            <input type="radio" name="tecnologia" value="CSS" ngModel />
            <input type="radio" name="tecnologia" value="JavaScript" ngModel />
        </div>

________________________________________________________    
CHECKBOX: Mesmo padrão dos de cima.

________________________________________________________
SELECTED | OPTIONS

    <select name="Filial" ngModel>
        <option value="Brasilia">Brasilia</option>
        <option value="Tres Coracoes">Tres Corações</option>
        <option value="Varginha">Varginha</option>
    </select>
________________________________________________________
VALIDANDO INPUT

    <input type="text" name="inputValidation" #inputValidation="ngModel" required ngModel/>

    Daí a partir do nome que associei a ngModel, #inputValidation, consigo acessar 3 propriedades principais:
        valid -> Se foi preenchido ou nao
        touched -> Se ja foi clicado pelo usuario
        dirty -> Se ja foi alterado ao menos uma vez pelo usuario

        basta usar: {{inputValidation.valid}}
    
________________________________________________________
ACESSANDO VALOR DO FORMULARIO

        {{myForm.value | json}}

________________________________________________________
SUBMIT DE UM FORMULÁRIO

        Basta incluir o evento ngSubmit e o referenciar a uma função do meu arquivo .ts  vinculado ao componente
    e passar como parametro o meu formulario para tratar os dados a serem enviados.

    <form #form="ngForm" (ngSubmit)="sendForm(form)">
    </form>